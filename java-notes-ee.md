##Beginning Apache Struts From Novice to Professional 
#Основы Java EE

 **Сервлет** является интерфейсом Java, реализация которого расширяет функциональные возможности сервера. Сервлет взаимодействует с клиентами посредством принципа запрос-ответ.

 Хотя сервлеты могут обслуживать любые запросы, они обычно используются для расширения веб-серверов. Для таких приложений технология Java Servlet определяет HTTP-специфичные сервлет классы. Пакеты javax.servlet и javax.servlet.http обеспечивают интерфейсы и классы для создания сервлетов.

 Сервлет – класс, отвечающий за обработку запросов клиента и отправку ответов.

 Основные методы сервлета: 
 - init() – запускается сразу после загрузки сервлета в память; 
 - service() – вызывается для обработки каждого запроса; 
 - destroy() – выполняется перед выгрузкой сервлета из памяти.

 Жизненный цикл сервлета: им управляет контейнер сервлетов, при первом обращении к сервлету происходит его загрузка в память и вызывается метод init(). На протяжении работы приложения происходят вызовы методы service() для обработки запросов клиента. По завершению работы приложения вызывается метод destroy() и сервлет выгружается из памяти.

 **Контейнер сервлетов**  — программа, представляющая собой сервер, который занимается системной поддержкой сервлетов и обеспечивает их жизненный цикл в соответствии с правилами, определёнными в спецификациях. Может работать как полноценный самостоятельный веб-сервер, быть поставщиком страниц для другого веб-сервера, например Apache, или интегрироваться в Java EE сервер приложений. Обеспечивает обмен данными между сервлетом и клиентами, берёт на себя выполнение таких функций, как создание программной среды для функционирующего сервлета, идентификацию и авторизацию клиентов, организацию сессии для каждого из них.

 Известные реализации:
 - Apache Tomcat
 - Jetty
 - JBoss
 - GlassFish
 - IBM WebSphere
 - Oracle Weblogic

 **Сервлеты**

 Чтобы кто там ни говорил, сервлет – это веб-страница, написанная на Java. Некоторые скажут, что я не прав и сервлет – это веб-приложение и что есть разница в этих понятиях, но это не так. Сейчас уже разницы нет, и сайты, написанные на PHP, тоже можно смело называть веб-приложениями. Теперь это полностью закономерно, т.к. php поддерживает ООП в полной мере, а такие CMS как Joomla активно этим пользуются.

 Что представляет собой сервлет на уровне кода? Это класс, в котором есть ряд методов, которые спят и видят, чтобы кто-то обратился к ним через GET или POST запросы HTTP. Т.е. набрали мы в браузере некоторый запрос GET, соответствующий метод класса сервлета его принимает и далее формирует ответ на него в виде html-страницы. В классическом понимании сервлета, как он был задуман еще Sun, эта страница так и отправлялась клиенту строчка за строчкой, начиная со строки <!DOCTYPE html> и заканчивая строкой </ html>.

 Таким образом, в Java есть базовый сервлет класс по имени Servlet. Кроме того, есть куча других классов, которые наследуются от этого базового класса и, тем самым, расширяют его функциональность.

 Вот, что такое сервлет – более ничего. Просто Java аналог PHP кода, который также выполняется на сервере, а клиенту посылается только ответ на запрос веб-браузера в виде веб-страницы. Всё.

 **Веб-фронт-энд-фреймворки**

 Подзаголовок сложноват и обычно все же пишут просто фронт-энд-фреймворк или даже веб-морда, но я решил здесь подчеркнуть, что когда речь идет о фронт-энд-фреймворках, то говорят о GUI для работы с Java через веб-браузер. Т.е. здесь опять идет речь о веб-сайтах на Java, т.е. о сервлетах.

 Что же представляет собой почти любой фронт-энд фреймфорк, к примеру, Apache Struts. Это просто набор классов, расширяющих базовый класс Servlet. Более ничего. Т.е. это просто другой способ создать тот же самый обычный сервлет. Просто разработчики этого фреймфорка (или иначе говоря, разработчики этой технологии) посчитали, что их дополнение базового Servlet-класса кое-какими методами будет более удобно для программиста, чем тот скудный функционал, что есть у классического сервлета от Sun/Oracle.

 **JSP-страницы**

 Практически сразу же в голову разработчиков концепции Java-сервлетов пришла еще одна идея. Раз уж мы пишем сервлет, задача которого – это отправка клиенту html-страницы, то может правильнее сразу написать эту html-страницу, а уж если понадобится какая-то логика на Java, то просто вставлять ее непосредственно в html. Если понятнее не стало, то может поможет фраза: jsp-страница – это аналог php-страницы. Сложно? Тогда еще поясню. Что мы делаем при написании страницы на php? У нас идет статический html, а когда нужно вставить всякую логику на php типа циклов и условий, то мы вставляет ее в тело тега <?php … ?>. С jsp все тоже самое, только логика пишется на чистой Java, код которой вставляется в тело тега <% … %>.

 Еще раз вернемся к понятию сервлета. По сути jsp-страница – это и есть сервлет, но записанный несколько иначе. В обычном сервлете мы пишем метод, который выполняет некоторую логику и по ее результатам формирует для клиента html-страницу. Просто через какое-то время разработчики сервлетов задумались, а что, если в методе не будет практически никакой логики, а будет идти почти одно лишь формирование html-страницы, то не проще ли будет писать сразу html-страницу, в которую делать минимальные вставки Java кода.

 Ну и последнее по поводу jsp-страниц. При первом обращении к такой странице она компилируется в сервлет и после этого выполняется. Последующие запросы к этой jsp-странице будут идти быстрее, т.к. она уже будет скомпилирована и ее нужно будет только выполнить.

 **Контейнер сервлетов**

 Вот написали мы класс сервлета или jsp-страницу. Что дальше? Как их запихнуть в веб-сервер, скажем apache, чтобы тот смог их отправить пользовательскому веб-браузеру? Веб-сервер может посылает только html, а если на нашей странице есть, скажем, php-код, то веб-сервер сначала пропускает страницу через интерпретатор, переводящий php в html, и только потом результат отправляется клиенту. С сервлетами происходит примерно тоже самое – перед отправкой их нужно выполнить, чтобы сформировалась html страница, а контейнер сервлетов как раз та самая штука, которая отвечает за выполнение сервлетов и кода jsp-страниц. Т.е. контейнер сервлетов для java — это аналог модуля php-интерпретатора в веб-сервере.

 Таким образом, когда пользователь в строке веб-браузера вводит адрес, этот запрос отправляется веб-серверу, веб-сервер понимает, что запрашивается сервлет, и передает запрос контейнеру сервлетов. После этого контейнер сервлетов выполняет сервлет, полученную html-страницу отправляет веб-серверу, а тот, в свою очередь, возвращает ее клиенту.

 Может ли контейнер сервлетов работать сам по себе, т.е. без веб-сервера? Такой как Tomcat – определенно может. И если мы хотим создать сайт, у которого не будет никаких других html-страниц, кроме как основанных на сервлетах, то контейнера сервлетов нам вполне достаточно. А вот если мы захотим комбинировать сайт из сервлетов и скажем php-страниц, то придется ставить веб-сервер. Причем не все веб-сервера имеют контейнер сервлетов в своем составе по умолчанию, зато почти все позволяют поставить его в качестве плагина.

 Поэтому если мы захотим запустить наш сайт на каком-нибудь хостинге в интернете, где, скорее всего, работает apache, то нам придется поинтересоваться у провайдера, подключен ли контейнер сервлетов.

 **JavaEE**

 Есть, так называемый, JavaSE (Java Standard Edition). К этому понятию относятся все классы java, для использования которых нам достаточно их просто импортировать (например, java.util.Date) или даже этого делать не надо (например, String, т.к. он располагается в пакете java.lang).

 А есть JavaEE (Java Enterprise Edition). Эти классы тоже принадлежат Sun/Oracle, но разница лишь в том, что их сложнее начать использовать в проекте. Простой строки import… будет недостаточно, т.к. проект компилироваться не будет. Для того чтобы исправить ситуацию, нужно будет найти файл библиотеки javaee.jar и подключить его в проект. Сделать это можно через свойства проекта в среде разработки. Часто говорят, что этот процесс подключения называется – прописать jar-ник в build path или classpath проекта.

 **Сервер приложений**

 Теперь представьте, что мы скомпилировали наш проект-сервлет, который использует JavaEE. Все замечательно, но нам теперь нужно разместить наши скомпилированные классы в контейнере сервлетов. Допустим, сделали. Будет ли наше приложение работать. Ответ – нет. При обращении к сервлету полетят исключительные ситуации, что какие-то классы не найдены. Почему? Потому что компилятор-то мы «обманули», подсунув javaee.jar в classpath, т.е. компилятор увидел, что классы из JavaEE на месте и успокоился, а вот контейнер сервлетов этих классов не видит, зато видит ссылки на них из нашего сервлета. Разрешима ли данная ситуация в рамках контейнера сервлетов. Конечно да, нужно просто в контейнере сервлетов в папку с нашим сервлетом добавить файл библиотеки javaee.jar.

 А теперь представьте, что таких проектов будет много и все они запущены в одном контейнере сервлетов Tomcat. Это значит, что в папку каждого сервлета придется копировать этот файлик jar. Это неудобно и неправильно. Ситуация разрешилась путем ввода понятия сервера приложения, в котором этот файлик уже давно лежит в единственном экземпляре, и все сервлеты могут к нему обращаться, а не иметь свою копию. На мой взгляд, очень удобно и логично. Естественно, весь сыр бор не из-за одно jar-файла (его я привел для примера) – таких файлов много.

 Но это не все, что дают нам сервера приложений. Сервера приложений могут сами держать соединения со многими ресурсами, например, с базой данных. При этом наш сервлет может сам такое соединение не открывать, а просто брать его из сервера приложений. В контейнере же сервлетов – это невозможно, т.к. контейнер – это, в определенной степени, урезанный сервер приложений. В контейнере сервлет должен всегда сам создавать коннекшены к базе. Как-то так…

 **war-архив**

 Что такое war-архив? WAR – это web-archive (веб-архив). На самом деле, это просто zip-файл, как и любой jar-ник. По сути, это всего лишь способ, чтобы наш веб-сайт, состоящий из множества веб-страниц, jsp-страниц и классов сервлетов запихать в один файлик формата zip.

 **web.xml**

 web.xml – это, так называемый, дескриптор развертывания. Это файл, в котором тупо описано, какой запрос строки веб-браузера на обработку какому классу-сервлету отправлять, чтобы контейнер сервлетов не запутался, какой сервлет за что отвечает.

 В целом, в Java очень модно описывать настройки во всяких xml-файлах, но в последнее время наметилась тенденция ухода от этой традиции. Как, спросите вы? А через аннотации. Классы-аннотации сами ничего не делают, они как раз и созданы только для того, чтобы всякие настройки (мета-данные) описывать не в отдельном xml-файле, а прямо по коду. Очень удобно. Однако сейчас наблюдается некая промежуточная стадия, когда часть настроек задана аннотациями, а часть через xml, и это может запутать, т.к. смотришь xml и видишь одну настройку, а по аннотациям стоит другая. Какая из них имеет высший приоритет? Кто знает…


#1 часть. Основы Struts

###2 глава. Обзор Servlet и JSP

 Контейнер сервлетов заботится о парсинге HTTP запросов, управлении сессиями, компилирует JavaServer страницы (JSP) и др.

 Сервелеты это Java-классы, которые пишутся для обработки HTTP запросов и ответов. Эти классы обычно являются подклассами HttpServlet.

###Основы контейнера сервлетов

 Веб-приложение - это WAR файл, который является обычным JAR файлом с расширением .war. Для развертывания веб-приложение необходимо просто скинуть этот war файл в директорию webapps. Tomcat автоматически установит его.

 WAR-архив должен содержать следующее:

 - *WEB-INF* директорию, в которой находится файл web.xml, использующийся для конфигурации веб-приложения. 
 - *WEB-INF\lib* директорию, в которой должны лежать все JAR файлы Struts, включая любые сторонние jar-файлы, используемые вашим приложением.
 - *WEB-INF\classes* директорию, в которой находятся .class файлы веб-приложения.
 - JSP, HTML, CSS, изображения и другие файлы. JSP и HTML файлы обычно находятся в корне WAR-архива, CSS обычно находится в поддиректории *styles*, изображения - поддиректория *images*.

 ![](http://i.imgur.com/JTACRm6.png)

 *Структура простого WAR файла*


###Важные классы сервлета

 - HttpServletRequest: используется для чтения значений параметров HTTP запроса и для чтения или установки атрибутов, которые могут быть получены с JSPs.
 - HttpSession: представляет текущую сессию пользователя. Как HttpServletRequest, HttpSession также имеет функции для получения и установки атрибутов, но они связаны 
с сессией пользователя, а не запросом.

 Эти объекты представляет собой области (scopes), или продолжительность жизни переменных вашего веб-приложения.

 Наиболее часто используемые функций этих классов:

 ![](http://i.imgur.com/8HD2lXR.png)

 *HttpServletRequest и HttpSession*

 Обратите внимание, что вы можете получить экземпляр HttpSession с помощью  
 метода getSession() класса HttpServletRequest.

###JavaServer Pages (JSP)

 Ранее, было упомянуто что сервлеты - это Java классы, которые генерируют соответствующий ответ на HTTP запрос. Этот ответ - это обычно HTML страница, отображающая результаты вычислений **(?)**.

 К сожалению, чистый Java класс не сможет просто сгенерировать HTML. Типичная веб-страница содержит много текста, и ваш класс, наследник сервлета, должен хранить этот текст где-то и предоставлять доступ к нему.

 В худшем случае Java класс содержал бы много HTML тегов и текста, это не очень красиво. Классы в Java код-ориентированны и не приспособлены к тому, чтобы позволить программисту легко отображать большие объемы текста, как веб-страницы.

 JavaServer Pages (JSP) - решение этой проблемы. Страницы JSP текст-ориентированные