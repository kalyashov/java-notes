#Заметки по Java
**По книге «Философия Java»**
##2 глава. Все является объектом

 Java основан на С++, но является более ОО языком, относится к семейству смешанных языков. Java подразумевает, что вы занимаетесь  только ООП. 

 В Java почти все является объектом.Для работы с объектами используются ссылки. 
 В Java вы обращаетесь с любыми данными как с объектом, и поэтому повсюду используется единый последовательный синтаксис. Хотя вы обращаетесь со всеми данными как с объектом, идентификатор, которым вы манипулируете, на самом деле представляет собой ссылку на объект. Например, для хранения слова или предложения создается ссылка String:

	String s;

 Однако здесь определяется только ссылка, но не сам объект. Нужно инициализировать ссылку при ее создании:

	String s = “abs”;

Все объекты должны создаваться явно. Когда определяется ссылка, то желательно присоединить ее к новому объекту (при помощи ключевого слова new).

	String s = new String(“abs”);

###Где хранятся данные

5 разных мест для хранения:

 - Регистры (Данные хранятся прямо внутри процессора. У вас нет прямого доступа к регистрам)
 
 - Стек (Находится в общей оперативной памяти - RAM. Ссылки на объекты хранятся в стеке, но сами объекты не помещаются в стек. Быстрый способ)

 - Куча (Пул памяти общего назначения, находится в RAM, в нем размещаются все объекты Java.  new - память выделяется из кучи)
  
 - Постоянное хранилище (Значения констант часто встраиваются прямо в код программы, т.к. они неизменны. Иногда такие данные могут размещаться в постоянной памяти ROM)
 
 - Внешнее хранилище (Если данные хранятся вне программы, он могут существовать и тогда, когда она не выполняется. Пример: потоковые объекты (для передачи на другие машины) и долгоживущие объекты (запоминаются на диске))

 *Особый случай: примитивные типы*

 Требуют особого обращения, так как часто применяются, и в куче недостаточно эффективно хранить. Java следует по примеру С и С++, вместо создания переменной с помощью new создается «автоматическая»  переменная, не являющаяся ссылкой. Она хранит значение и располагается в стеке, операции с ней гораздо производительнее.

 Неизменность размера типа переменной – одна из причин улучшенной переносимости программ Java.

###Массивы
	
 Одной из основных целей Java является безопасность. Массивы гарантированно инициализируются, и к ним невозможен доступ за пределами его границ. Проверка границ массива обходится дорого, но повышение безопасности стоит того.

 При объявлении массива объектов на самом деле создается массив ссылок, и каждая из этих ссылок автоматически инициализируется null. 

 Массивы простейших типов заполняются нулями. Объекты никогда не приходится удалять - сборщик мусора все сделает сам.

 Область действия объектов отличается от области действия примитивов. Объект созданный оператором new, будет доступен до конца области действия. Если написать:

	{
		String s = new String(“sd);
	} // конец области действия 

 Ссылка s исчезнет в конце области действия. Однако сам объект, на который указывала ссылка, все еще будет занимать память. Уборщик мусора, который наблюдает за объектами, созданными оператором new,  определяет, на какие из них больше нет ссылок, тогда он освобождает память этих объектов, которая становится доступной для дальнейшего использования. Таким образом, никогда не придется очищать память вручную.

 Если переменная используется как член класса, то гарантируется значение по-умолчанию (для int это 0 и т.п.). Такая гарантия не относится к локальным переменным, которые не являются полями класса, переменная будет инициализирована случайным значением.

 Методы в Java определяют сообщения, принимаемые объектом. Имя метода и его список аргументов (объединяемые термином сигнатура) обеспечивают однозначную идентификацию метода.

###Видимость имен

 Для создания уникальных имен библиотек разработчики Java предлагают использовать доменное имя, записанное в обратном порядке, так как эти имена всегда уникальны.

 В Java не существует проблемы опережающих ссылок.

###Ключевое слово static

 Объект появляется только после того, как он будет создан ключевым словом new, и только начиная с этого момента для него выделяется память и появляется возможность вызова методов. Но есть две ситуации, в которых такой подход недостаточен. Первая – это когда некоторые данные должны храниться в единственном числе независимо от того, сколько было создано объектов класса. Вторая – когда требуется метод, не привязанный ни к какому конкретному объекту класса, то есть метод, который можно вызвать даже при полном отсутствии объектов класса.

 Такой эффект достигается использованием ключевого слова static, делающего элемент класса статическим. Данные или метод, объявленные как static,  не привязаны к определенному экземпляру этого класса.  

 Следующий код создает статическое поле класса и инициализирует его:

	Class StaticTest
	{
		static int i = 47;
	} 

 Теперь даже при создании двух объектов этого класса, для элемента StaticTest.i выделяется единственный блок памяти. Оба объекта совместно используют одно значение i.

 Для обращения к статической переменной есть возможность обращаться прямо через имя класса:
	
	StaticTest.i++;
	
 То же самое касается статических методов класса. Для нестатических членов такая возможность отсутствует. 
	
###Документация в комментариях
	
 Для упрощения ведения документации, код и документацию объединяют в одном файле, но для полноты картины нужен специальный синтаксис комментариев, чтобы помечать документацию, и инструмент, который извлекал бы эти комментарии и оформлял их в подходящем виде. 

 Инструмент для извлечения комментариев называется **javadoc**, он является частью пакета JDK.  Он не только извлекает помеченную информацию, но также узнает имя класса или метода, к которому относится данный фрагмент документации. Результатом работы программы является html-файл. Также можно дополнить javadoc своими собственными расширениями, называемыми доклетами, в которых можно проводить специальные операции над обрабатываемыми данными.

##3 глава. Операторы

###Простые команды печати

Вместо `System.out.println("…");` можно использовать команду `print("..."); ` но нужно сделать статический импорт:

	import static net.minview.util.Print.*;

###Присваивание

 Присваивание объектов отличается от обычного присваивания. При выполнении операций с объектом вы в действительности работаете со ссылкой, поэтому присваивание одного объекта другому в действительности означает копирование ссылки из одного места в другое. Это означает, что при выполнении команды c = d для объектов в конечном итоге c и d указывают на один объект, которому изначально соответствовала только ссылка d. Во многих языках программирования можно было ожидать, что c и d будут независимы все время, но из-за присваивания ссылок изменение объекта c будет отражаться на объекте d. Это происходит из-за того, что t1 и t2 содержат одинаковые ссылки, указывающие на один объект. (Исходная ссылка, которая содержалась в с и указывала на объект с определенным значением, была перезаписана во время присваивания и фактически потеряна, её объект будет вскоре удален уборщиком мусора.)

 Этот феномен совмещения имен часто называют синонимией (aliasing), и именно она является основным способом работы с объектами в Java. 

 Но что делать, если совмещение имен нежелательно?  Тогда можно пропустить присваивание и записать: 

	c.value = d.value; 

 При этом программа сохранит 2 разных объекта. Но прямая работа с полями данных внутри объектов противоречит принципам ООП.

###Автоувеличение и автоуменьшение

 Каждый из этих операторов существует в двух версиях – префиксной и постфиксной. Префиксный инкремент значит, что оператор ++ записывается перед переменной или выражением, а при постфиксном инкременте оператор следует после переменной или выражения. Аналогично, при префиксном декременте. Для префиксного инкремента и декремента сначала выполняется операция, а затем выдается результат. Для постфиксной записи сначала выдается значение и лишь затем выполняется операция.
	
###Операторы сравнения
	
 Для сравнения объектов можно использовать метод equals(), который нужно переопределять в собственных классах.
	
###Ускоренное вычисление
	
 При работе с логическими операторами можно столкнуться с феноменом, называемым «ускоренным вычислением». Это значит,  что выражение вычисляется только до тех пор, пока не станет очевидно, что он принимает значение «истина» или «ложь». В результате некоторые части логического выражения могут быть проигнорированы в процессе сравнения. Это обеспечивает потенциальный выигрыш в производительности.
	
###Литералы
	
 - 0x2f – шестнадцатеричное число (нижний регистр)
 - 0X2F – шестнадцатеричное число (верхний регистр)
 - 0177 – восьмеричное число (нижний регистр)
 - 200L - long
 - 200l – long(можно запутаться)
 - 1F - float
 - 1f - float
 - 1D - double
 - 1d – double

###Экспоненциальная запись

 е означает 10 в степени. 

	float expFloat = 1.39e – 43f;  

 Это 1.39 * 10^-43

###Тернарный оператор

 Логическое-условие ? выражение0 : выражение1

 Может ухудшить читаемость кода, обычно его применение ограничивается присваиванием переменной одного из двух значений.

###Перегрузка операторов

 В языке Java отсутствует перегрузка операторов.

###Оператор + и += для String

	int x = 0;
	String s ="x";
	print(s + x);
	print(x + " " + s); //Преобразует x в String
	print(" " + x); //Сокращение для Integer.toString();

###Привидение типов

 В случае с типами *char*, *byte* и *short* можно заметить эффект повышения при использовании арифметических операторов. Любая арифметическая операция с этими типами дает результат типа int, который затем нужно явно приводить к изначальному типу (сужающие привидение, при котором возможно потеря информации).

##4 глава. Управляющие конструкции

 В Java задействованы все управляющие конструкции языка С.
 *If-else*, *while*, *do-while*, *for*, *return*, *break*, *switch*.

###Оператор-запятая

 Позволяет записать несколько переменных в цикле for, но все эти переменные должны быть одного типа:

	for (int i = 0, j = I + 10; i < 5; i++, j = i * 2) 
	{} 

###Синтаксис foreach
 
 В Java SE5 появилась новая, более компактная форма for для перебора элементов массивов и контейнеров. Не требует ручного изменения переменной int для перебора последовательности объектов – цикл автоматически представляет очередной элемент.

 **Пример:**
 
	for (char c : "An African Swallow".toCharArray() )
	System.out.print(c + " ");

 Синтаксис foreach также работает для любого объекта, поддерживающего интерфейс Iterable.

###Break и continue
	
 Команда break завершает цикл, при этом оставшиеся операторы цикла не выполняются. Команда continue останавливает выполнение текущей итерации цикла и переходит к началу цикла, чтобы начать выполнение нового шага или же вернуться в начало цикла.

###Команда goto

 Java не имеет команды goto, однако существует механизм, похожий на безусловный переход.
 Метка представляет собой идентификатор с последующим двоеточием:

	label1:
	
 Единственное место, где в Java метка может оказаться полезной,- прямо перед телом цикла. Обычные версии break прерывают лишь текущий цикл, но с помощью метки можно досрочно завершать циклы и передавать выполнение в точку, адресуемую меткой:

	label1:
	внешний цикл 
	{
			внутренний цикл 
			{
				…
				break;
				…
				continue;	
				…
				continue label1;
				…
				break label1;
			}
	}

 В третьем варианте команда влечет выход из обоих циклов и выполнение цикла начинается снова с внешнего цикла. В 4 варианте команда останавливает действие обоих циклов, повторный вход в итерацию не происходит.

##5 глава. Инициализация и завершение.

###Конструктор

 Конструктор, не получающий аргументов, называется конструктором по умолчанию. Конструкторы не возвращают никогда и ничего. 

###Перегрузка методов

 Даже разного порядка аргументов достаточно для того, чтобы методы считались разными. Но такой подход почти не используется, так как он усложняет сопровождение программного кода.

###Ключевое слово this

 Употребляется только в особых случаях, когда необходимо сослаться на текущий объект. Может использоваться только внутри нестатического метода и предоставляет ссылку на объект, для которого был вызван метод. При вызове метода вашего класса из другого метода класса использовать this не нужно.

 Для передачи текущего объекта внешнему методу используется ключевое слово this:

	class Person 
	{
  		public void eat(Apple apple) 
		{
    		Apple peeled = apple.getPeeled();
    		System.out.println("Yummy");
  		}
	}

	class Peeler 
	{
  		static Apple peel(Apple apple) 
		{
    		// ... remove peel
    		return apple; // Peeled
  		}
	}

    class Apple 
	{
      	Apple getPeeled() { return Peeler.peel(this); }
    }
    
    public class PassingThis 
	{
      	public static void main(String[] args) 
		{
    		new Person().eat(new Apple());
      	}
    } 

 **Output:**
 >Yummy


###Вызов конструкторов из конструкторов

 Иногда бывает удобно вызвать один конструктор из другого, чтобы избежать дублирования кода. Такая операция проводится с использованием this.

 Обычно при употреблении this подразумевается *“текущий объект”*, но в конструкторе это ключевое слово имеет другой смысл: при использовании его со списком аргументов вызывается конструктор, соответствующий данному списку. Таким образом, появляется возможность прямого вызова других конструкторов:

	/: initialization/Flower.java
	// Calling constructors with "this"
	import static net.mindview.util.Print.*;
	
	public class Flower 
	{
	  	int petalCount = 0;
	  	String s = "initial value";
	  	Flower(int petals) 
		{
			petalCount = petals;
			print("Constructor w/ int arg only, petalCount= "
	  		+ petalCount);
	  	}
	  
		Flower(String ss) 
		{
			print("Constructor w/ String arg only, s = " + ss);
			s = ss;
	 	}
	  
		Flower(String s, int petals) 
		{
			this(petals);
			//!this(s); // Can't call two!
			this.s = s; // Another use of "this"
			print("String & int args");
	  	}
	  
		Flower() 
		{
			this("hi", 47);
			print("default constructor (no args)");
	  	}
	  
		void printPetalCount() 
		{
			//! this(11); // Not inside non-constructor!
			print("petalCount = " + petalCount + " s = "+ s);
	  	}

	  	public static void main(String[] args) 
		{
			Flower x = new Flower();
			x.printPetalCount();
	  	}
	} 

**Output:**
>Constructor w/ int arg only, petalCount= 47 

>String & int args 

>default constructor (no args) 

>petalCount = 47 s = hi 


 При вызове одного конструктора через this вызывать второй запрещается. Вдобавок вызов другого конструктора должен быть первой выполняемой операцией, иначе компилятор выдаст сообщение об ошибке.

###Значение ключевого слова static

 У статических методов не существует ссылки this. Статические методы вызываются для класса, без каких-либо объектов.

###Очистка: финализация и уборка мусора

 Уборщик мусора умеет освобождать память, выделенную оператором new, но ему неизвестно, как следует очищать специфическую память объекта. Для таких ситуаций в Java предусмотрен метод finalize(), который можно определить в собственном классе. Когда уборщик мусора готов освободить память, использованную вашим объектом, то он для начала вызывает метод и только после этого освобождает занимаемую объектом память. Таким образом, метод finalize() позволяет выполнить завершающие действия во время работы уборщика мусора, но не стоит путать его с деструктором языка C++ - ф-ей, всегда вызываемой перед разрушением объекта. В Java объекты не всегда удаляются уборщиком мусора. Уборка мусора не является уничтожением.

 Если перед тем, как объект станет ненужным, необходимо выполнить некоторое завершающее действие, то это действие придется выполнить собственноручно.

###Для чего нужен метод finalize()?

 Похоже, что поддержка метода finalize() была введена в язык, чтобы сделать возможными операции с памятью в стиле С, с привлечением нестандартных механизмов выделения памяти. Это может произойти в основном при использовании методов, предоставляющих способ вызова не-Java-кода из программы на Java. В действительности программа Java может вызвать любую процедуру или функцию на любом языке. Во внешнем коде можно выделить память вызовом функций С, относящихся к семейству malloc().

 Метод finalize() используется нечасто.

###Как работает уборщик мусора

**Дописать**

###Инициализация членов класса 

 Члены класса автоматически инициализируются. Ссылке на объект автоматически присваивается значение null.

###Явная инициализация

 Прямое присваивание значения переменной прямо в точке ее объявления в классе.

###Инициализация конструктором

 Переменные инициализируются внутри конструктора, но сначала пройдет автоматическая инициализация.

###Порядок инициализации

 Внутри класса очередность инициализации определяется порядком следования переменных, объявленных в этом классе. Определения переменных могут быть разбросаны по разным определениям методов, но в любом случае переменные инициализируются перед вызовом любого метода – даже конструктора.

###Инициализация статических данных

 Данные статических полей всегда существуют в единственном экземпляре, независимо от количества созданных объектов. Ключевое слово static не может применяться к локальным переменным, только к полям. 

 Если статическое поле относится к примитивному типу, при отсутствии явной инициализации ему присваивается значение по умолчанию. Если это ссылка на объект, то ей присваивается значение null.

 Статическая инициализация происходит только в случае необходимости. Они инициализируются только при создании первого объекта (или при первом обращении к статическим данным). После этого статические объекты заново не инициализируются.

 Сначала инициализируются статические члены, если они еще не были проинициализированы, и только затем нестатические объекты.

 Обобщим знания о процессе создания объекта. Для примера возьмем класс с именем Dog:

 - Хотя ключевое слово static  и не используется явно, конструктор в действительности является статическим методом. При создании первого объекта типа Dog  или при первом вызове статического метода/обращения к статическому полю класса Dog интерпретатор Java должен найти класс Dog.class. Поиск осуществляется в стандартных каталогах, перечисленных в переменной окружения CLASSPATH.
 
 - После загрузки Dog.class (с созданием особого объекта Class) производится инициализация статических элементов. Таким образом, инициализация статических членов проводится только один раз, при первой загрузке объекта Class.
 
 - При создании нового объекта конструкцией new Dog() для начала выделяется блок памяти, достаточный для хранения объекта Dog в куче.

 - Выделенная память заполняется нулями, при этом все примитивные поля объекта автоматически инициализируются значениями по умолчанию.
 
 - Выполняются все действия по инициализации, происходящие в точке определения полей класса.
 -
 - Выполняются конструкторы. 

###Явная инициализация статических членов

 Java позволяет сгруппировать несколько действий по инициализации объектов static в специальной конструкции, называемой статическим блоком. 

 Этот код, как и остальная инициализация static, выполняется только один раз: при первом создании объекта этого класса или при первом обращении к статическим членам этого класса (даже если ни один объект класса не создается).

**Пример:**

	import static net.mindview.util.Print.*;
	
	class Cup 
	{
		Cup(int marker) 
		{
			print("Cup(" + marker + ")");
		}
		  
		void f(int marker) 
		{
			print("f(" + marker + ")");
		}
	}
		
	class Cups 
	{
		static Cup cup1;
		static Cup cup2;
		
		static 
		{
			cup1 = new Cup(1);
			cup2 = new Cup(2);
		}
		  
		Cups() 
		{
			print("Cups()");
		}
	}
		
	public class ExplicitStatic 
	{
		public static void main(String[] args) 
		{
			print("Inside main()");
			Cups.cup1.f(99);  // (1)
		}
	  	// static Cups cups1 = new Cups();  // (2)
	  	// static Cups cups2 = new Cups();  // (2)
	} 

**Output:**
>Inside main() 

>Cup(1) 

>Cup(2) 

>f(99)


###Инициализация нестатических данных экземпляра

 Имеется схожий синтаксис для инициализации нестатических переменных для каждого объекта:

	import static net.mindview.util.Print.*;
	
	class Mug 
	{
	  	Mug(int marker) 
		{
	    	print("Mug(" + marker + ")");
	  	}
	  
		void f(int marker) 
		{
	    	print("f(" + marker + ")");
	  	}
	}
	
	public class Mugs 
	{
	  	Mug mug1;
	  	Mug mug2;

	  	{
	    	mug1 = new Mug(1);
	    	mug2 = new Mug(2);
	    	print("mug1 & mug2 initialized");
	  	}

	  	Mugs() 
		{
	    	print("Mugs()");
	  	}

	  	Mugs(int i) 
		{
	    	print("Mugs(int)");
	  	}

	  	public static void main(String[] args) 
		{
	    	print("Inside main()");
	    	new Mugs();
	    	print("new Mugs() completed");
	    	new Mugs(1);
	    	print("new Mugs(1) completed");
	  	}
	} 
**Output:**
>Inside main() 

>Mug(1) 

>Mug(2) 

>mug1 & mug2 initialized 

>Mugs() 

>new Mugs() completed 

>Mug(1) 

>Mug(2) 

>mug1 & mug2 initialized 

>Mugs(int) 

>new Mugs(1) completed 


 Такой синтаксис необходим для поддержки инициализации анонимных внутренних классов, но он также гарантирует, что некоторые операции будут выполнены независимо от того, какой именно конструктор был вызван в программе. Секция инициализации экземпляра выполняется раньше любых конструкторов.

###Инициализация массивов

 Массивы определяются и используются с помощью оператора индексирования [ ]. Чтобы определить ссылку на массив в программе нужно написать:

	int[] a1;

 Квадратные скобки также могут размещаться после идентификатора, эффект будет точно таким же:

    int a1[];

 Инициализация:

	int a1 = { 1, 2, 3, 4, 5 };

 В Java можно присвоить один массив другому:

	a2 = a1;

 В данном случае *скопируются ссылки*.

 Все массивы содержат поле, которое можно только прочитать – length (количество элементов в массиве).

 Есть метод Arrays.toString(), входящий в стандартную библиотеку java.util, метод выдает печатную версию одномерного массива.

###Списки аргументов переменной длины
	
 Такой список способен содержать неизвестное заранее количество аргументов неизвестного типа. Так как абсолютно все классы являются производными от общего корневого класса Object, можно создать метод, принимающий в качестве аргумента массив Object:

	class A { int i; }
	
	public class VarArgs 
	{
	 	static void printArray(Object[] args) 
		{
	    	for(Object obj : args)
	      		System.out.print(obj + " ");

	    	System.out.println();
	  	}

	  	public static void main(String[] args) 
		{
	    	printArray(new Object[]
			{
	      		new Integer(47), new Float(3.14), new Double(11.11)
	    	});

	    	printArray(new Object[]{"one", "two", "three" });
	    	printArray(new Object[]{new A(), new A(), new A()});
	  	}
	} 
**Output:** (Sample)

>47 3.14 11.11 

>one two three 

>A@1a46e30 A@3e25a5 A@19821f 

 Print() принимает массив объектов типа Object, перебирает его элементы и выводит их.

 До выхода Java SE5 переменные списки аргументов реализовывались именно так. В Java SE5 была добавлена возможность – для определения переменного списка аргументов может использоваться многоточие:

	public class NewVarArgs 
	{
	  	static void printArray(Object... args) 
		{
	    	for(Object obj : args)
	      		System.out.print(obj + " ");
	    	System.out.println();
	  	}

	  	public static void main(String[] args) 
		{
	    	// Can take individual elements:
	    	printArray(new Integer(47), new Float(3.14),
	    	  new Double(11.11));

	    	printArray(47, 3.14F, 11.11);
	    	printArray("one", "two", "three");
	    	printArray(new A(), new A(), new A());

	    	// Or an array:
	    	printArray((Object[])new Integer[]{ 1, 2, 3, 4 });
	    	printArray(); // Empty list is OK
	  	}
	} 

**Output: (75% match)**
>47 3.14 11.11 

>47 3.14 11.11 

>one two three

>A@1bab50a A@c3c749 A@150bd4d 

>1 2 3 4

 Списки аргументов переменной длины избавляют от необходимости явной записи синтаксиса массивов – компилятор делает это автоматически.

 Списки аргументов переменной длины могут использоваться и с другими типами:

	public class OptionalTrailingArguments 
	{
	  	static void f(int required, String... trailing) 
		{
	    	System.out.print("required: " + required + " ");
	    	for(String s : trailing)
	      		System.out.print(s + " ");

	    	System.out.println();
	  	}

	  	public static void main(String[] args) 
		{
	    	f(1, "one");
	    	f(2, "two", "three");
	    	f(0);
	  	}
	} 

**Output:**
>required: 1 one

>required: 2 two three

>required: 0 


 Следующий пример показывает, что список аргументов переменной длины превращается в массив, а при отсутствии элементов он становится массивом нулевой длины.
	
	public class VarargType 
	{
	  	static void f(Character... args) 
		{
	    	System.out.print(args.getClass());
	    	System.out.println(" length " + args.length);
	  	}

	  	static void g(int... args) 
		{
	    	System.out.print(args.getClass());
	    	System.out.println(" length " + args.length);
	  	}

	  	public static void main(String[] args) 
		{
	    	f('a');
	    	f();
	    	g(1);
	    	g();
	    	System.out.println("int[]: " + new int[0].getClass());
	  	}
	} 

**Output:**
>class [Ljava.lang.Character; length 1 </br>
>class [Ljava.lang.Character; length 0 </br>
>class [I length 1 </br>
>class [I length 0 </br>
>int[]: class [I </br>


 Можно вызывать функцию вообще без аргументов.

 Списки аргументов переменной длины могут усложнит перегрузку. При вызове перегруженной функции без аргументов компилятор не сможет определиться какой из методов следует вызвать. Как правило, список аргументов переменной длины следует использовать только в одной версии перегруженного метода.

###Перечисления

 Ключевое слово **enum** введено в Java SE5. Оно значительно упрощает работу программиста при группировке и использовании перечисляемых типов.

	public enum Spiciness 
	{
	  	NOT, MILD, MEDIUM, HOT, FLAMING
	}

 Приведенный фрагмент создает перечислимый тип с именем Spiciness, состоящий из 4 именованных значений. Так как экземпляры перечислимых типов являются константами, то по правилом они записываются исключительно прописными буквами (если имя состоит из нескольких слов, то эти слова разделяются пробелами).

 Чтобы использовать перечисление нужно создать ссылку на перечислимый тип:

	public class SimpleEnumUse 
	{
	  	public static void main(String[] args) 
		{
	    	Spiciness howHot = Spiciness.MEDIUM;
	    	System.out.println(howHot);
	  	}
	} 

**Output:**
>MEDIUM


 На самом деле перечисления являются классами и обладают своими методами, вот некоторые из них:

 **toString()** –вывод имени экземпляра перечислимого типа. </br>
 **ordinal()** – порядок объявления констант. </br>
 **values()** – возвращает массив констант в enum  в порядке их объявления. 

Удобно использовать switch для работы с enum.

##6 глава. Управление доступом.

 Смысл управления доступом (или сокрытия реализации) заключается в постепенном совершенствовании кода.

 *Рефакторинг* – переработки работоспособности кода, направленного на то, чтобы сделать его более удобочитаемым и понятным и упростить сопровождение.

###Пакет как библиотечный модуль

 Пакет содержит группу классов, объединенных  в одном пространстве имен. Для импорта классов пакета используется ключевое слово import.
 
 Файл с исходным текстом на Java часто называют компилированным модулем. Файл .java может содержать один и только один открытый класс (public).

###Структура кода

 В результате компиляции для каждого класса, определенного в файле .java, создается класс с тем же именем, но с расширением .class. На компилируемом языке компилятор генерирует промежуточные файлы (.OBJ обычно), которые затем объединяются компоновщиком для получения исполняемого файла или библиотеки. Java  работает не так. Рабочая программа представляет собой набор однородных файлов .class, которые объединяются в пакет и сжимаются в файл JAR (утилитой Java jar). Интерпретатор Java отвечает за поиск, загрузку и интерпретацию этих файлов.

 Ключевые слова package и import позволяют разработчику библиотеки организовать логическое  деление глобального пространства имен, предотвращающее конфликты имен независимо от того, сколько людей подключатся к Интернету и начнут писать свои классы на Java.

###Конфликты имен

 Предположим, что программа содержит следующие директивы:

	import net.mindview.simple.*;
	import java.util.*;

 Эти пакеты содержат класс с именем *Vector*. Конфликт произойдет при попытке создать *Vector*: 

	Vector v = new Vector();

 Компилятор выдаст сообщение об ошибке и заставит явно указать нужное имя:

	java.util.Vector v = new java.util.Vector();

###Пользовательские библиотеки

 После компиляции методы пользовательских библиотек могут использоваться где угодно, для чего угодно, но нужно чтобы файл располагался в одном из каталогов, указанных в переменной окружения *CLASSPATH*. Затем в программу достаточно включить директиву `import static`.

###Спецификаторы доступа Java

 В Java спецификаторы доступа *public*, *protected* и *private* располагаются перед определением членов классов – как полей, так и методов. Каждый спецификатор доступа управляет только одним отдельным определением.

 Если спецификатор доступа не указан, то используется «пакетный» уровень доступа.

###Доступ в пределах пакета

 Доступ по умолчанию не имеет ключевого слова, но часто его называют доступом в пределах пакета. Это значит, что член класса доступен для всех остальных классов текущего пакета, но для классов за пределами пакета он воспринимается как приватный.

###Public

Объявление члена класса доступно для всех.

###Private

Доступ к члену класса не предоставляется никому, кроме методов этого класса. Сокрытие данных.

###Protected

Связано с понятием наследования. (Будет рассмотрено далее)

###Интерфейс и реализация

 Контроль над доступом часто называют сокрытием реализации. Помещение данных и методов в классы в комбинации с сокрытием реализации часто называют инкапсуляцией. 

 Доступ к типам данных ограничивается по двум причинам: 

 - Первая причина – программист-клиент должен знать, что он может использовать, а что не может. 
 - Вторая причина – разделение интерфейса и реализации.

  Для большей ясности при написании классов можно использовать такой стиль: сначала записываются *public*-члены, затем *protected*-члены, затем члены с доступом в пределах пакета и, наконец, закрытые члены(*private*). Преимущество такой схемы в том, что при чтении исходного текста пользователь сначала видит то, что ему важно, а затем останавливается при переходе к закрытым членам, являющимся частью внутренней реализации.

###Доступ к классам

 В Java с помощью спецификаторов доступа возможно также указать, какие из классов внутри библиотеки будут доступны для ее пользователей. Если нужно, чтобы класс был открыт программисту-клиенту, то нужно добавить *public* для класса в целом.
	
 Существуют некоторые ограничения:

 - В каждом компилируемом модуле может существовать только один открытый (*public*) класс. Идея в том, что каждый компилируемый модуль содержит определенный открытый интерфейс и реализуется этим открытым классом. В модуле может содержаться произвольное количество вспомогательных классов с доступом в пределах пакета.

 - Имя открытого класса должно в точности совпадать с именем файла, в котором содержится компилируемый модуль. 

 - Компилируемый модуль может вообще не содержать открытых классов (хотя это и не типично). В этом случае файлу можно присвоить любое имя по вашему усмотрению.

  Класс нельзя объявить как *private* (что сделает класс недоступным для окружающих,   использовать он сможет только сам себя) или *protected*. Поэтому выбор при задании доступа к классу небольшой: в пределах пакета или открытый(*public*).

  Если вы хотите перекрыть доступ к классу для всех, то нужно объявить все его конструкторы со спецификатором private, соответственно запрещая кому бы то ни было создание объектов этого класса. Только вы сами, в статическом методе этого класса, сможете создавать такие объекты. 

 **Пример:**

	class Soup1 
	{
	  	private Soup1() {}
	  	// (1) Allow creation via static method:
	  
		public static Soup1 makeSoup() 
		{
	    	return new Soup1();
	  	}
	}
	
	class Soup2 
	{
	  	private Soup2() {}
	  	// (2) Create a static object and return a reference
	  	// upon request.(The "Singleton" pattern):
	  	
		private static Soup2 ps1 = new Soup2();
	  	
		public static Soup2 access() 
		{
	    	return ps1;
	  	}

	 	public void f() {}
	}
	
	// Only one public class allowed per file:
	public class Lunch 
	{
	  	void testPrivate() 
		{
	    	// Can't do this! Private constructor:
	    	//! Soup1 soup = new Soup1();
	  	}
	  	
		void testStatic() 
		{
	    	Soup1 soup = Soup1.makeSoup();
	  	}
	  
		void testSingleton() 
		{
	    	Soup2.access().f();
	  	}
	} 

 Без явного определения хотя бы одного конструктора компилятор сгенерирует конструктор по-умолчанию.

##7 глава. Повторное использование классов.

 Есть два пути реализации этой идеи. Первый довольно прямолинеен: объекты уже имеющихся классов просто создаются внутри вашего нового класса. Механизм построения нового класса из объектов существующих классов называется композицией (*composition*). Вы просто используете функциональность готового кода, а не его структуру.

 Второй способ интереснее – новый класс создается как специализация уже существующего класса. Взяв существующий класс за основу, вы добавляете к нему свой код без изменения существующего класса. Этот механизм называется наследованием (*inheritance*), и большую часть работы в нем совершает компилятор.

###Синтаксис композиции

 Ссылка на внедряемый объект просто включается в новый класс. Компилятор не создает объектов для ссылок «по умолчанию», и это логично, потому что во многих случаях это привело бы к лишним затратам ресурсов. Если вам понадобится проинициализировать ссылку, то нужно сделать это самостоятельно:

 - В точке определения объекта. Это значит, что объект всегда будет инициализироваться перед вызовом конструктора.
 - В конструкторе данного класса.
 - Перед использованием объекта. Этот способ часто называют отложенной инициализацией. Он может сэкономить ресурсы в ситуациях, где создавать объект каждый раз необязательно и накладно.
 - С использованием инициализации экземпляров.

 Все 4 способа продемонстрированы в следующем примере:

	import static net.mindview.util.Print.*;
	
	//Инициализация в конструкторе с композицией
	class Soap {
	  private String s;
	  Soap() {
	    print("Soap()");
	    s = "Constructed";
	  }
	  public String toString() { return s; }
	}	
	
	public class Bath {
	  private String // Initializing at point of definition:
	    s1 = "Happy",
	    s2 = "Happy",
	    s3, s4;
	  private Soap castille;
	  private int i;
	  private float toy;
	  public Bath() {
	    print("Inside Bath()");
	    s3 = "Joy";
	    toy = 3.14f;
	    castille = new Soap();
	  }	
	  // Instance initialization:
	  { i = 47; }
	  public String toString() {
	    if(s4 == null) // Delayed initialization:
	      s4 = "Joy";
	    return
	      "s1 = " + s1 + "\n" +
	      "s2 = " + s2 + "\n" +
	      "s3 = " + s3 + "\n" +
	      "s4 = " + s4 + "\n" +
	      "i = " + i + "\n" +
	      "toy = " + toy + "\n" +
	      "castille = " + castille;
	  }	
	  public static void main(String[] args) {
	    Bath b = new Bath();
	    print(b);
	  }
	} 
**Output:**
>Inside Bath()

>Soap()

>s1 = Happy

>s2 = Happy

>s3 = Joy 

>s4 = Joy 

>i = 47 

>toy = 3.14 

>castille = Constructed 


###Синтаксис наследования

 Фактически наследование всегда используется при создании класса, потому что даже если класс не объявляется производным от другого класса, он автоматически становится производным от корневого класса Java *Object*.

 При использовании наследования вы говорите: «Этот новый класс похож на тот старый класс». В программе этот факт выражается перед фигурной скобкой, открывающей тело класса: сначала записывается ключевое слово *extends*, а затем имя базового класса. Тем самым вы автоматически получаете доступ ко всем полям и методам базового класса. 

**Пример:**

	// Inheritance syntax & properties.
	import static net.mindview.util.Print.*;
	
	class Cleanser 
	{
	  	private String s = "Cleanser";

	  	public void append(String a) { s += a; }

	  	public void dilute() { append(" dilute()"); }

	  	public void apply() { append(" apply()"); }

	  	public void scrub() { append(" scrub()"); }

	  	public String toString() { return s; }

	  	public static void main(String[] args) 
		{
	    	Cleanser x = new Cleanser();
	    	x.dilute(); x.apply(); x.scrub();
	    	print(x);
	  	}
	}	
	
	public class Detergent extends Cleanser 
	{
	  	// Change a method:
	  	public void scrub() 
		{
	    	append(" Detergent.scrub()");
	    	super.scrub(); // Call base-class version
	  	}

	  	// Add methods to the interface:
	  	public void foam() { append(" foam()"); }

	  	// Test the new class:
	  	public static void main(String[] args) 
		{
	    	Detergent x = new Detergent();
	    	x.dilute();
	    	x.apply();
	    	x.scrub();
	    	x.foam();
	    	print(x);
	    	print("Testing base class:");
	    	Cleanser.main(args);
	  	}	
	} 

**Output:**
>Cleanser dilute() apply() Detergent.scrub() scrub() foam() 

>Testing base class: 

>Cleanser dilute() apply() scrub() 

 Классы Cleanser и Detergent содержат метод main(). Даже если у вас в программе имеется множество классов, из командой строки исполняется только один (т.к. метод main() всегда объявляется как public, то неважно объявлен ли класс, в котором он описан, как public). Класс Cleanser не объявлен, но все равно можно вызвать метод `Cleanser.main()`. Даже если класс обладает доступом в пределах класса, открытый метод main() остается доступным.

 Здесь метод Detergent.main() вызывает Cleanser.main() явно, передавая ему собственный массив аргументов командной строки.

 При отсутствии спецификатора доступа член класса автоматически получает доступ "в пределах пакета", что позволяет обращаться к нему только из текущего пакета. Таким образом, в пределах данного пакета при отсутствии спецификатора доступа вызов этих методов разрешен кому угодно.

 В Java существует ключевое слово *super*, которое обозначает "суперкласс", то есть класс, производным от которого является текущий класс.

###Инициализация базового класса

 Наследование не просто копирует интерфейс базового класса. Когда вы создаете объект производного класса, внутри него содержится *подобъект* базового класса. Этот подобъект выглядит точно так же, как выглядел бы созданный обычным порядком объект базового класса. Поэтому извне представляется, будто бы в объекте производного класса "упакован" объект базового класса.

 Конечно, очень важно, чтобы подобъект базового класса был правильно инициализирован, и гарантировать это можно только одним способом: выполнить инициализацию в конструкторе, вызывая при этом конструктор базового класса, у которого есть необходимые знания и привилегии для проведения инициализации базового класса. Java автоматически вставляет вызовы конструктора базового класса в конструктор производного класса. В следующем примере задействовано 3 уровня наследования:

	//: reusing/Cartoon.java
	// Constructor calls during inheritance.
	import static net.mindview.util.Print.*;
	
	class Art 
	{
	  	Art() { print("Art constructor"); }
	}
	
	class Drawing extends Art 
	{
	  	Drawing() { print("Drawing constructor"); }
	}
	
	public class Cartoon extends Drawing 
	{
	  	public Cartoon() { print("Cartoon constructor"); }
	  	public static void main(String[] args) 
		{
	    	Cartoon x = new Cartoon();
	  	}
	} 

**Output:**
>Art constructor

>Drawing constructor

>Cartoon constructor


 Конструирование начинается с самого внутреннего базового класса. Даже если конструктор класса Carton не определен, компилятор сгенерирует конструктор по умолчанию, в котором также вызывается конструктор базового класса.

###Конструкторы с аргументами

 Если класс не имеет конструктора по умолчанию или вам понадобится вызвать конструктор базового класса с аргументами, этот вызов придется оформить явно, с указанием ключевого слова *super* и передачей аргументов:

	
	//: reusing/Chess.java
	// Inheritance, constructors and arguments.
	import static net.mindview.util.Print.*;
	
	class Game 
	{
	  	Game(int i) 
		{
	    	print("Game constructor");
	  	}
	}
	
	class BoardGame extends Game 
	{
	  	BoardGame(int i) 
		{
	    	super(i);
	    	print("BoardGame constructor");
	  	}
	}	
	
	public class Chess extends BoardGame 
	{
	  	Chess() 
		{
	    	super(11);
	    	print("Chess constructor");
	  	}
	  
		public static void main(String[] args) 
		{
	  		Chess x = new Chess();
	  	}
	} 

**Output:**
>Game constructor

>BoardGame constructor

>Chess constructor


 Если не вызвать конструктор базового класса в BoardGame(), то компилятор "пожалуется" на то, что не может обнаружить конструктор в форме Game(). Вдобавок, _вызов конструктора базового класс должен быть первой командой в конструкторе производного класса_.

###Делегирование

 Третий вид отношений, не поддерживаемый в Java напрямую, называется *делегированием*. Он занимает промежуточное положение между наследованием и композицией: экземпляр существующего класса включается в создаваемый класс (как при композиции), но в то же время все методы встроенного объекта становятся доступными в новом классе (как при наследовании). 

**Пример:**
 
 Класс SpaceShipControls имитирует модуль управления космическим кораблем:

	//: reusing/SpaceShipControls.java

	public class SpaceShipControls 
	{
	  	void up(int velocity) {}
	  	void down(int velocity) {}
	  	void left(int velocity) {}
	  	void right(int velocity) {}
	  	void forward(int velocity) {}
	  	void back(int velocity) {}
	  	void turboBoost() {}
	 } 
  
 Для построения космического корабля можно воспользоваться наследованием:

	//: reusing/SpaceShip.java

	public class SpaceShip extends SpaceShipControls 
	{
	  	private String name;
	 	public SpaceShip(String name) { this.name = name; }
	  	public String toString() { return name; }
	  	public static void main(String[] args) 
		{
	    	SpaceShip protector = new SpaceShip("NSEA Protector");
	    	protector.forward(100);
	  	}
	 } 

 Однако космический корабль не может рассматриваться как частный случай своего управляющего модуля - несмотря на то, что ему, к примеру можно приказать двигаться вперед (forward()). SpaceShip *содержит* SpaceShipControls, и в то же время все методы последнего предоставляются классом SpaceShip.

 Проблема решается при помощи делегирования:

	//: reusing/SpaceShipDelegation.java
	
	public class SpaceShipDelegation 
	{
	  	private String name;
	  	private SpaceShipControls controls =
	    	new SpaceShipControls();

	  	public SpaceShipDelegation(String name) 
		{
	    	this.name = name;
	  	}

	  	// Delegated methods:
	  	public void back(int velocity) 
		{
	    	controls.back(velocity);
	  	}

	  	public void down(int velocity) 
		{
	    	controls.down(velocity);
	  	}

	  	public void forward(int velocity) 
		{
	    	controls.forward(velocity);
	  	}

	  	public void left(int velocity)
		{
	    	controls.left(velocity);
	  	}

	  	public void right(int velocity) 
		{
	    	controls.right(velocity);
	  	}

	  	public void turboBoost() {
	    	controls.turboBoost();
	  	}

	  	public void up(int velocity) {
	    	controls.up(velocity);
	  	}

	  	public static void main(String[] args) 
		{
	    	SpaceShipDelegation protector =
	      		new SpaceShipDelegation("NSEA Protector");
	    	protector.forward(100);
	  	}
	} 
	
 Вызовы методов переадресуются встроенному объекту controls, а интерфейс остается таким же, как и при наследовании. С другой стороны, делегирование позволяет лучше управлять происходящим, потому что вы можете ограничиться небольшим подмножеством методов встроенного объекта.
 
###Сочетание композиции и наследования 

 Композиция очень часто используется вместе с наследованием. 

 **Пример:**

	//: reusing/PlaceSetting.java
	// Combining composition & inheritance.
	import static net.mindview.util.Print.*;
	
	class Plate {
	  Plate(int i) {
	    print("Plate constructor");
	  }
	}
	
	class DinnerPlate extends Plate {
	  DinnerPlate(int i) {
	    super(i);
	    print("DinnerPlate constructor");
	  }
	}	
	
	class Utensil {
	  Utensil(int i) {
	    print("Utensil constructor");
	  }
	}
	
	class Spoon extends Utensil {
	  Spoon(int i) {
	    super(i);
	    print("Spoon constructor");
	  }
	}
	
	class Fork extends Utensil {
	  Fork(int i) {
	    super(i);
	    print("Fork constructor");
	  }
	}	
	
	class Knife extends Utensil {
	  Knife(int i) {
	    super(i);
	    print("Knife constructor");
	  }
	}
	
	// A cultural way of doing something:
	class Custom {
	  Custom(int i) {
	    print("Custom constructor");
	  }
	}	
	
	public class PlaceSetting extends Custom {
	  private Spoon sp;
	  private Fork frk;
	  private Knife kn;
	  private DinnerPlate pl;
	  public PlaceSetting(int i) {
	    super(i + 1);
	    sp = new Spoon(i + 2);
	    frk = new Fork(i + 3);
	    kn = new Knife(i + 4);
	    pl = new DinnerPlate(i + 5);
	    print("PlaceSetting constructor");
	  }
	  public static void main(String[] args) {
	    PlaceSetting x = new PlaceSetting(9);
	  }
	} 

**Output:**	
>Custom constructor

>Utensil constructor

>Spoon constructor

>Utensil constructor

>Fork constructor

>Utensil constructor

>Knife constructor

>Plate constructor

>DinnerPlate constructor

>PlaceSetting constructor

###Обеспечение правильного завершения

 В Java отсутствует понятие деструктора из C++ - метода, автоматически вызываемого при уничтожении объекта. В Java программисты просто "забывают" об объектах, не уничтожая их самостоятельно, так как функции очистки памяти возложены на уборщика мусора.

 Во многих случаях эта модель работает, но иногда требуются завершающие действия в секции *finally*.

	/: reusing/CADSystem.java
	// Ensuring proper cleanup.
	package reusing;
	import static net.mindview.util.Print.*;
	
	class Shape {
	  Shape(int i) { print("Shape constructor"); }
	  void dispose() { print("Shape dispose"); }
	}
	
	class Circle extends Shape {
	  Circle(int i) {
	    super(i);
	    print("Drawing Circle");
	  }
	  void dispose() {
	    print("Erasing Circle");
	    super.dispose();
	  }
	}
	
	class Triangle extends Shape {
	  Triangle(int i) {
	    super(i);
	    print("Drawing Triangle");
	  }
	  void dispose() {
	    print("Erasing Triangle");
	    super.dispose();
	  }
	}
	
	class Line extends Shape {
	  private int start, end;
	  Line(int start, int end) {
	    super(start);
	    this.start = start;
	    this.end = end;
	    print("Drawing Line: " + start + ", " + end);
	  }
	  void dispose() {
	    print("Erasing Line: " + start + ", " + end);
	    super.dispose();
	  }
	}
	
	public class CADSystem extends Shape {
	  private Circle c;
	  private Triangle t;
	  private Line[] lines = new Line[3];
	  public CADSystem(int i) {
	    super(i + 1);
	    for(int j = 0; j < lines.length; j++)
	      lines[j] = new Line(j, j*j);
	    c = new Circle(1);
	    t = new Triangle(1);
	    print("Combined constructor");
	  }
	  public void dispose() {
	    print("CADSystem.dispose()");
	    // The order of cleanup is the reverse
	    // of the order of initialization:
	    t.dispose();
	    c.dispose();
	    for(int i = lines.length - 1; i >= 0; i--)
	      lines[i].dispose();
	    super.dispose();
	  }
	  public static void main(String[] args) {
	    CADSystem x = new CADSystem(47);
	    try {
	      // Code and exception handling...
	    } finally {
	      x.dispose();
	    }
	  }
	} 

**Output:**
>Shape constructor

>Shape constructor

>Drawing Line: 0, 0

>Shape constructor

>Drawing Line: 1, 1

>Shape constructor

>Drawing Line: 2, 4

>Shape constructor

>Drawing Circle

>Shape constructor

>Drawing Triangle

>Combined constructor

>CADSystem.dispose()

>Erasing Triangle

>Shape dispose

>Erasing Circle

>Shape dispose

>Erasing Line: 2, 4

>Shape dispose

>Erasing Line: 1, 1

>Shape dispose

>Erasing Line: 0, 0

>Shape dispose

>Shape dispose

 Ключевое слово try показывает, что следующий за ним блок является защищенной секцией. Код в секции finally выполняется всегда, независимо от того, как прошло выполнение блока try -  при обработке исключений можно выйти из блока try некоторыми необычными способами. (12 глава.)

 Порядок вызова завершающих методов соответствует последовательности обратной порядку создания объектов.

###Сокрытие имен

 Если какой-либо из методов базового класса Java был перегружен несколько раз, переопределение имени этого метода в производном классе *не скроет* ни одну из базовых версий (в отличие от С++). 


	//: reusing/Hide.java
	// Overloading a base-class method name in a derived
	// class does not hide the base-class versions.
	import static net.mindview.util.Print.*;
	
	class Homer {
	  char doh(char c) {
	    print("doh(char)");
	    return 'd';
	  }
	  float doh(float f) {
	    print("doh(float)");
	    return 1.0f;
	  }
	}
	
	class Milhouse {}
	
	class Bart extends Homer {
	  void doh(Milhouse m) {
	    print("doh(Milhouse)");
	  }
	}
	
	public class Hide {
	  public static void main(String[] args) {
	    Bart b = new Bart();
	    b.doh(1);
	    b.doh('x');
	    b.doh(1.0f);
	    b.doh(new Milhouse());
	  }
	} 

**Output:**
>doh(float)

>doh(char)

>doh(float)

>doh(Milhouse)

 Все перегруженные методы класса Homer доступны классу Bart, хотя класс Bart и добавляет новый перегруженный метод (в С++ такое действие спрятало бы все методы базового класса). 

 На практике при переопределении методов гораздо чаще используется точно такое же описание и список аргументов, как и в базовом классе (иначе можно легко запутаться).

 В Java SE5 появилась аннотация `@Override` она не является ключевым словом, но может использоваться так, как если бы была им. Если вы собираетесь переопределить метод, используйте `@Override`, и компилятор выдаст сообщение об ошибке, если вместо переопределения будет случайно выполнена перегрузка.

###Композиция в сравнении с наследованием

 Когда следует выбирать одно, а когда другое?

 Композиция в основном используется, когда в новом классе необходимо задействовать функциональность уже существующего класса (через определенный вами интерфейс), но не его интерфейс. 

 Иногда требуется предоставить пользователю прямой доступ к композиции вашего класса, то есть сделать встроенный объект открытым. Встроенные объекты и сами используют сокрытие реализации, поэтому открытый доступ безопасен. 

 Когда пользователь знает, что класс собирается из составных частей, ему значительно легче понять его интерфейс. 

 **Пример:**

	//: reusing/Car.java
	// Composition with public objects.
	
	class Engine {
	  public void start() {}
	  public void rev() {}
	  public void stop() {}
	}
	
	class Wheel {
	  public void inflate(int psi) {}
	}
	
	class Window {
	  public void rollup() {}
	  public void rolldown() {}
	}
	
	class Door {
	  public Window window = new Window();
	  public void open() {}
	  public void close() {}
	}
	
	public class Car {
	  public Engine engine = new Engine();
	  public Wheel[] wheel = new Wheel[4];
	  public Door
	    left = new Door(),
	    right = new Door(); // 2-door
	  public Car() {
	    for(int i = 0; i < 4; i++)
	      wheel[i] = new Wheel();
	  }
	  public static void main(String[] args) {
	    Car car = new Car();
	    car.left.window.rollup();
	    car.wheel[0].inflate(72);
	  }
	} 

 Взаимосвязь "является" выражается наследованием, а взаимосвязь "имеет" описывается композицией.
 
###protected

 Ключевое слово *protected* означает, что член класса является закрытым для пользователя класса, но для всех, кто наследует от класса и для соседей по пакету он доступен. (В Java protected автоматически предоставляет доступ в пределах пакета.)

 Управляемый доступ наследникам класса предоставляется через методы protected:

	//: reusing/Orc.java
	// The protected keyword.
	import static net.mindview.util.Print.*;
	
	class Villain {
	  private String name;
	  protected void set(String nm) { name = nm; }
	  public Villain(String name) { this.name = name; }
	  public String toString() {
	    return "I'm a Villain and my name is " + name;
	  }
	}	
	
	public class Orc extends Villain {
	  private int orcNumber;
	  public Orc(String name, int orcNumber) {
	    super(name);
	    this.orcNumber = orcNumber;
	  }
	  public void change(String name, int orcNumber) {
	    set(name); // Available because it's protected
	    this.orcNumber = orcNumber;
	  }
	  public String toString() {
	    return "Orc " + orcNumber + ": " + super.toString();
	  }	
	  public static void main(String[] args) {
	    Orc orc = new Orc("Limburger", 12);
	    print(orc);
	    orc.change("Bob", 19);
	    print(orc);
	  }
	} 

**Output:**
>Orc 12: I'm a Villain and my name is Limburger

>Orc 19: I'm a Villain and my name is Bob

###Восходящее преобразование типов

 Наследование выражает отношения между новым и базовым классом - новый класс является разновидностью существующего.

	//: reusing/Wind.java
	// Inheritance & upcasting.
	
	class Instrument {
	  public void play() {}
	  static void tune(Instrument i) {
	    // ...
	    i.play();
	  }
	}
	
	// Wind objects are instruments
	// because they have the same interface:
	public class Wind extends Instrument {
	  public static void main(String[] args) {
	    Wind flute = new Wind();
	    Instrument.tune(flute); // Upcasting
	  }
	} 

 Преобразование ссылки на объект Wind в ссылку на объект Instrument называется *восходящим преобразованием типов* (upcasting).

 Восходящее преобразование всегда безопасно, так как это переход от конкретного типа к более общему типу. Иначе говоря, производный класс является надстройкой базового класса. Он может содержать больше методов, чем базовый класс, но обязан включать в себя все методы базового класса.

 Единственное, что может произойти с интерфейсом класса при восходящем преобразовании,- потеря методов, но никак не их приобретение. Именно поэтому компилятор всегда разрешает выполнять восходящее преобразование, не требуя явных преобразований или других специальных обозначений.

###Снова о композиции и наследовании

 В теории ООП очень много внимания уделяется наследованию, но это не значит, что его следует без разбора применять всюду.

 Один из хороших критериев выбора между композицией и наследованием - спросить себя, собираетесь ли вы впоследствии проводить восходящее преобразование от производного класса к базовому классу.

###Ключевое слово final

 *final* накладывает запрет на изменения.

 3 возможных применения final:

- для данных
- для методов
- для классов 

###Неизменные данные

 Для примитивов final делает постоянным значения, а для ссылки на объект постоянной становится ссылка, такая ссылка уже не сможет указывать на другой объект. Впрочем, сам объект при этом может измениться.

 В Java нет механизмов, позволяющих сделать произвольный объект неизменным (Можно написать класс так, чтобы его объекты фактически были константными.) Данное ограничение относится и к массивам, которые тоже являются объектами.

 Поле, одновременно объявленное с ключевыми словами static и final, существует в памяти в единственном экземпляре и не может быть изменено.

	//: reusing/FinalData.java
	// The effect of final on fields.
	import java.util.*;
	import static net.mindview.util.Print.*;
	
	class Value {
	  int i; // Package access
	  public Value(int i) { this.i = i; }
	}
	
	public class FinalData {
	  private static Random rand = new Random(47);
	  private String id;
	  public FinalData(String id) { this.id = id; }
	  // Can be compile-time constants:
	  private final int valueOne = 9;
	  private static final int VALUE_TWO = 99;
	  // Typical public constant:
	  public static final int VALUE_THREE = 39;
	  // Cannot be compile-time constants:
	  private final int i4 = rand.nextInt(20);
	  static final int INT_5 = rand.nextInt(20);
	  private Value v1 = new Value(11);
	  private final Value v2 = new Value(22);
	  private static final Value VAL_3 = new Value(33);
	  // Arrays:
	  private final int[] a = { 1, 2, 3, 4, 5, 6 };
	  public String toString() {
	    return id + ": " + "i4 = " + i4 + ", INT_5 = " + INT_5;
	  }
	  public static void main(String[] args) {
	    FinalData fd1 = new FinalData("fd1");
	    //! fd1.valueOne++; // Error: can't change value
	    fd1.v2.i++; // Object isn't constant!
	    fd1.v1 = new Value(9); // OK -- not final
	    for(int i = 0; i < fd1.a.length; i++)
	      fd1.a[i]++; // Object isn't constant!
	    //! fd1.v2 = new Value(0); // Error: Can't
	    //! fd1.VAL_3 = new Value(1); // change reference
	    //! fd1.a = new int[3];
	    print(fd1);
	    print("Creating new FinalData");
	    FinalData fd2 = new FinalData("fd2");
	    print(fd1);
	    print(fd2);
	  }
	} 

**Output:**
>fd1: i4 = 15, INT_5 = 18

>Creating new FinalData

>fd1: i4 = 15, INT_5 = 18

>fd2: i4 = 13, INT_5 = 18

 Само по себе присутствие final еще не означает, что значение переменной известно уже на стадии компиляции. 

###Пустые константы
 
 В Java разрешается создавать пустые константы - поля, объявленные как final, но которым не присвоено начальное значение. Во всех случаях пустую константу обязательно нужно инициализировать перед использованием.

	//: reusing/BlankFinal.java
	// "Blank" final fields.
	
	class Poppet {
	  private int i;
	  Poppet(int ii) { i = ii; }
	}
	
	public class BlankFinal {
	  private final int i = 0; // Initialized final
	  private final int j; // Blank final
	  private final Poppet p; // Blank final reference
	  // Blank finals MUST be initialized in the constructor:
	  public BlankFinal() {
	    j = 1; // Initialize blank final
	    p = new Poppet(1); // Initialize blank final reference
	  }
	  public BlankFinal(int x) {
	    j = x; // Initialize blank final
	    p = new Poppet(x); // Initialize blank final reference
	  }
	  public static void main(String[] args) {
	    new BlankFinal();
	    new BlankFinal(47);
	  }
	}

###Неизменные аргументы

 Это значит, что метод не может изменить значение, на которое указывает передаваемая ссылка:

	//: reusing/FinalArguments.java
	// Using "final" with method arguments.
	
	class Gizmo {
	  public void spin() {}
	}
	
	public class FinalArguments {
	  void with(final Gizmo g) {
	    //! g = new Gizmo(); // Illegal -- g is final
	  }
	  void without(Gizmo g) {
	    g = new Gizmo(); // OK -- g not final
	    g.spin();
	  }
	  // void f(final int i) { i++; } // Can't change
	  // You can only read from a final primitive:
	  int g(final int i) { return i + 1; }
	  public static void main(String[] args) {
	    FinalArguments bf = new FinalArguments();
	    bf.without(null);
	    bf.with(null);
	  }
	} 
 
 Эта возможность чаще всего используется при передаче данных анонимным внутренним классам.

###Неизменные методы

 Неизменные методы используются по двум причинам:

 - Первая причина - "блокировка" метода, чтобы производные классы не могли изменить его содержание. Это делается по соображениям проектирования, когда вам точно надо знать, что поведение метода не изменится при наследовании.
 - Второй причиной в прошлом считалась эффективность. В более ранних реализациях Java объявление метода с ключевым словом final позволяло компилятору превратить все вызовы такого метода во встроенные (inline). Когда компилятор видит метод, объявленный как final, он может (на свое усмотрение) пропустить стандартный механизм вставки кода для проведения вызова метода (занести аргументы в стек, перейти к телу метода, исполнить находящийся там код, вернуть управление, удалить аргументы из стека и распорядиться возвращенным значением) и вместо этого подставить на место вызова копию реального кода, находящегося в теле метода. Таким образом устраняются издержки вызова метода. 

 В последних версиях Java виртуальная машина выявляет подобные ситуации и устраняет лишние передачи управления при оптимизации, поэтому использовать final для методо уже нежелательно.

 Следует объявлять методы final только в том случае, если вы хотите явно запретить переопределение.

###Спецификаторы final и private

 Любой закрытый метод в классе косвенно является неизменным методом, так как вы не в силах получить доступ к закрытому методу, то не сможете и переопределить его. 

 Это может вызвать недоразумения, так как при попытке переопределения закрытого метода, также неявно являющегося final, все вроде бы работает, и компилятор не выдает сообщений об ошибках: 

	//: reusing/FinalOverridingIllusion.java
	// It only looks like you can override
	// a private or private final method.
	import static net.mindview.util.Print.*;
	
	class WithFinals {
	  // Identical to "private" alone:
	  private final void f() { print("WithFinals.f()"); }
	  // Also automatically "final":
	  private void g() { print("WithFinals.g()"); }
	}
	
	class OverridingPrivate extends WithFinals {
	  private final void f() {
	    print("OverridingPrivate.f()");
	  }
	  private void g() {
	    print("OverridingPrivate.g()");
	  }
	}
	
	class OverridingPrivate2 extends OverridingPrivate {
	  public final void f() {
	    print("OverridingPrivate2.f()");
	  }
	  public void g() {
	    print("OverridingPrivate2.g()");
	  }
	}
	
	public class FinalOverridingIllusion {
	  public static void main(String[] args) {
	    OverridingPrivate2 op2 = new OverridingPrivate2();
	    op2.f();
	    op2.g();
	    // You can upcast:
	    OverridingPrivate op = op2;
	    // But you can't call the methods:
	    //! op.f();
	    //! op.g();
	    // Same here:
	    WithFinals wf = op2;
	    //! wf.f();
	    //! wf.g();
	  }
	} 

**Output:**
>OverridingPrivate2.f()

>OverridingPrivate2.g()

 "Переопределение" применимо только к компонентам интерфейса базового класса. Иначе говоря, вы должны иметь возможность выполнить восходящее преобразование объекта к его базовому типу и вызвать тот же самый метод. Если метод объявлен как private, он не является частью интерфейса базового класса, это просто некоторый код, скрытый внутри класса, у которого осталось то же имя. 
 
 Если вы создаете в производном классе одноименный метод со спецификатором public, protected или с доступом в пределах пакета, то он никак не связан с закрытым методом базового класса. Так как private метод недоступен и фактически невидим для окружающего мира, он не влияет ни на что, кроме внутренней организации кода в классе, где он был описан.

###Неизменные классы

 Объявляя класс неизменным, вы показываете, что не собираетесь использовать этот класс в качестве базового при наследовании и запрещаете это делать другим.

 Другими словами, по какой-то причине структура класса должна оставаться постоянной - или же появление субклассов нежелательно по  соображениям безопасности.

	//: reusing/Jurassic.java
	// Making an entire class final.
	
	class SmallBrain {}
	
	final class Dinosaur {
	  int i = 7;
	  int j = 1;
	  SmallBrain x = new SmallBrain();
	  void f() {}
	}
	
	//! class Further extends Dinosaur {}
	// error: Cannot extend final class 'Dinosaur'
	
	public class Jurassic {
	  public static void main(String[] args) {
	    Dinosaur n = new Dinosaur();
	    n.f();
	    n.i = 40;
	    n.j++;
	  }
	}
 
 Из-за того, что final запрещает наследование от класса, то все методы в неизменном классе также являются неизменными, поскольку нет способа переопределить их.

###Инициализация и загрузка классов

 В традиционных языках программы загружаются целиком в процессе запуска. Далее следует инициализация, а затем программа начинает работу. Процесс инициализации в таких языках должен тщательно контролироваться, чтобы порядок инициализации статических объектом не создавал проблем. Например, в С++ могут возникнуть проблемы, когда один из статических объектов полагает, что другим статическим объектом уже можно пользоваться, хотя последний еще не инициализирован.

 В Java таких проблем нет, поскольку в нем используется другой подход к загрузке. Скомпилированный код каждого класс хранится в отдельном файле. Этот файл не загружается, пока не возникнет такая необходимость. В сущности, код класса загружается только в точке его первого использования. Обычно это происходит при создании первого объекта класса, но загрузка также выполняется при обращениях к статическим полям или методам.

 Конструктор также является статически методом, хотя ключевое слово static и не указывается явно. Таким образом, формально загрузка класса выполняется при первом обращении к любому из его статических методов.
 
 Точкой первого использования также является точка выполнения инициализации статических членов. Все статические объекты и блоки кода инициализируются при загрузке класса в том порядке, в котором они записаны в определении класса. Конечно, статические объекты инициализируются только один раз.

###Инициализация с наследованием

**Пример:**

	//: reusing/Beetle.java
	// The full process of initialization.
	import static net.mindview.util.Print.*;
	
	class Insect {
	  private int i = 9;
	  protected int j;
	  Insect() {
	    print("i = " + i + ", j = " + j);
	    j = 39;
	  }
	  private static int x1 =
	    printInit("static Insect.x1 initialized");
	  static int printInit(String s) {
	    print(s);
	    return 47;
	  }
	}
	
	public class Beetle extends Insect {
	  private int k = printInit("Beetle.k initialized");
	  public Beetle() {
	    print("k = " + k);
	    print("j = " + j);
	  }
	  private static int x2 =
	    printInit("static Beetle.x2 initialized");
	  public static void main(String[] args) {
	    print("Beetle constructor");
	    Beetle b = new Beetle();
	  }
	} 

**Output:**
>static Insect.x1 initialized

>static Beetle.x2 initialized

>Beetle constructor

>i = 9, j = 0

>Beetle.k initialized

>k = 47

>j = 39

 Запуск класса Beetle начинается с выполнения метода Beetle.main(), загрузчик пытается найти скомпилированный код класса Beetle (он должен находиться в файле Beetle.class). При этом загрузчик обнаруживает, что у класса имеется базовый класс (extends), который затем и загружается.

 Это происходит независимо от того, собираетесь вы создавать объекты базового класса или нет.

 Затем проводится static-инициализация корневого базового класса, затем следующего за ним производного класса и т.д. 

 В этой точке все необходимые классы уже загружены и можно переходить к созданию объекта класса. Сначала всем примитивам данного объекта присваиваются значения по-умолчанию, а ссылкам на объекты задается null - делается это за один подход посредством обнуления памяти. Затем вызывается конструктор базового класса (Автоматически или через super). После завершения работы конструктора базового класса инициализируются переменные, в порядке их определения. Наконец, выполняется оставшееся тело конструктора.

##Полиморфизм







